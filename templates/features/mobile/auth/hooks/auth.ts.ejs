import { useCallback, useState, useEffect } from 'react';
import { Platform } from 'react-native';
import { useSession, authClient, getCookies } from '../lib/auth-client';
import Constants from 'expo-constants';
<% if (features.authentication.twoFactor) { %>
import AsyncStorage from '@react-native-async-storage/async-storage';

const TWO_FACTOR_EXPIRES_KEY = '@auth:two_factor_expires_at';
const TWO_FACTOR_TIMEOUT_SECONDS = 180;
const SAFETY_BUFFER_SECONDS = 5;
<% } %>
<% if (features.authentication.providers.google) { %>
import { GoogleSignin, statusCodes } from '@react-native-google-signin/google-signin';
<% } %>
<% if (features.authentication.providers.apple) { %>
import * as AppleAuthentication from 'expo-apple-authentication';
<% } %>

// Get API URL from Expo config
const API_URL = Constants.expoConfig?.extra?.apiUrl || 'http://localhost:8080';

/**
 * Auth hook using BetterAuth's useSession() directly
 *
 * This hook provides:
 * - Reactive auth state from BetterAuth's SecureStore
 * - Auth actions (signIn, signUp, signOut, etc.)
 * - Loading and error state for UI feedback
 */
export const useAuth = () => {
  const { data: session, isPending, error: sessionError, refetch } = useSession();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
<% if (features.authentication.twoFactor) { %>
  // 2FA expiration state
  const [twoFactorExpiresAt, setTwoFactorExpiresAtState] = useState<number | null>(null);

  // Load persisted 2FA expiration on mount
  useEffect(() => {
    AsyncStorage.getItem(TWO_FACTOR_EXPIRES_KEY).then((value) => {
      if (value) {
        const expiresAt = parseInt(value, 10);
        // Only restore if not already expired
        if (expiresAt > Math.floor(Date.now() / 1000)) {
          setTwoFactorExpiresAtState(expiresAt);
        } else {
          AsyncStorage.removeItem(TWO_FACTOR_EXPIRES_KEY);
        }
      }
    });
  }, []);

  // Setter that persists to AsyncStorage
  const setTwoFactorExpiration = useCallback(async (expiresAt: number | null) => {
    setTwoFactorExpiresAtState(expiresAt);
    if (expiresAt) {
      await AsyncStorage.setItem(TWO_FACTOR_EXPIRES_KEY, expiresAt.toString());
    } else {
      await AsyncStorage.removeItem(TWO_FACTOR_EXPIRES_KEY);
    }
  }, []);

  // Clear 2FA state (used after expiration or successful verification)
  const clearTwoFactorState = useCallback(async () => {
    setTwoFactorExpiresAtState(null);
    await AsyncStorage.removeItem(TWO_FACTOR_EXPIRES_KEY);
  }, []);
<% } %>

  // Computed state from BetterAuth session
  const isAuthenticated = !!(session?.user && session?.session);
  const user = session?.user ?? null;

  // Sign in with email/password
  const signIn = useCallback(async (credentials: { email: string; password: string }) => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await authClient.signIn.email({
        email: credentials.email,
        password: credentials.password,
      });
<% if (features.authentication.twoFactor) { %>
      // Check if 2FA is required (Better Auth returns twoFactorRedirect: true)
      if (result.data?.twoFactorRedirect) {
        // Calculate expiration: current time + backend timeout - safety buffer
        // The safety buffer ensures mobile expires BEFORE backend (same pattern as web's Max-Age fallback)
        const expiresAt = Math.floor(Date.now() / 1000) + TWO_FACTOR_TIMEOUT_SECONDS - SAFETY_BUFFER_SECONDS;
        await setTwoFactorExpiration(expiresAt);
        return { success: true, requiresTwoFactor: true, twoFactorExpiresAt: expiresAt };
      }
<% } %>
      if (result.error) {
        throw new Error(result.error.message || 'Sign in failed');
      }
      return { success: true };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Sign in failed';
      setError(message);
      return { success: false, error: message };
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Sign up with email/password
  const signUp = useCallback(async (data: { email: string; password: string; name: string }) => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await authClient.signUp.email({
        email: data.email,
        password: data.password,
        name: data.name,
      });
      if (result.error) {
        throw new Error(result.error.message || 'Sign up failed');
      }
<% if (features.authentication.emailVerification) { %>
      // Check if email verification is required
      // When emailOTP plugin is enabled with sendVerificationOnSignUp,
      // the user needs to verify their email before being signed in
      return { success: true, needsEmailVerification: true, email: data.email };
<% } else { %>
      return { success: true };
<% } %>
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Sign up failed';
      setError(message);
      return { success: false, error: message };
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Sign out
  const signOut = useCallback(async () => {
    setIsLoading(true);
    try {
      await authClient.signOut();
      return { success: true };
    } catch (err) {
      // Still considered success - BetterAuth will clear local state
      return { success: true };
    } finally {
      setIsLoading(false);
    }
  }, []);
<% if (features.authentication.providers.google) { %>
  /**
   * Google Sign In with native SDK + browser fallback
   * - Native: Uses @react-native-google-signin for best UX (requires dev build)
   * - Fallback: Opens browser for OAuth (works in Expo Go, without Play Services)
   */
  const signInWithGoogle = useCallback(async (
    callbackURL: string = "/(tabs)",
    errorCallbackURL: string = "/(auth)/login"
  ) => {
    setIsLoading(true);
    setError(null);

    try {
      // Try native sign-in first
      let idToken: string | null = null;

      try {
        GoogleSignin.configure({
          webClientId: Constants.expoConfig?.extra?.googleOAuth?.webClientId,
          iosClientId: Constants.expoConfig?.extra?.googleOAuth?.iosClientId,
        });

        await GoogleSignin.hasPlayServices({ showPlayServicesUpdateDialog: true });
        const userInfo = await GoogleSignin.signIn();
        idToken = userInfo.data?.idToken || null;
      } catch (nativeError: any) {
        // Native failed - check if user cancelled
        if (nativeError.code === statusCodes.SIGN_IN_CANCELLED) {
          throw new Error('Sign in cancelled');
        }

        // Fall back to browser OAuth (Expo Go, no Play Services, etc.)
        console.log('Native Google Sign-In unavailable, using browser fallback');
        const result = await authClient.signIn.social({
          provider: 'google',
          callbackURL,
          errorCallbackURL,
        });

        if (result.error) {
          throw new Error(result.error.message || 'Google sign in failed');
        }
        return { success: true };
      }

      // Native succeeded - send ID token to Better Auth
      if (!idToken) {
        throw new Error('No ID token received from Google');
      }

      const result = await authClient.signIn.social({
        provider: 'google',
        idToken: {
          token: idToken,
        },
      });

      if (result.error) {
        throw new Error(result.error.message || 'Google sign in failed');
      }
      return { success: true };
    } catch (err: any) {
      const message = err instanceof Error ? err.message : 'Google sign in failed';
      setError(message);
      return { success: false, error: message };
    } finally {
      setIsLoading(false);
    }
  }, []);
<% } %>
<% if (features.authentication.providers.apple) { %>
  /**
   * Apple Sign In with native SDK + browser fallback
   * - iOS: Uses expo-apple-authentication for Face ID, native bottom sheet
   * - Android/Fallback: Opens browser for OAuth
   */
  const signInWithApple = useCallback(async (
    callbackURL: string = "/(tabs)",
    errorCallbackURL: string = "/(auth)/login"
  ) => {
    setIsLoading(true);
    setError(null);

    try {
      // iOS: Try native Apple Sign In
      if (Platform.OS === 'ios') {
        const isAvailable = await AppleAuthentication.isAvailableAsync();

        if (isAvailable) {
          try {
            const credential = await AppleAuthentication.signInAsync({
              requestedScopes: [
                AppleAuthentication.AppleAuthenticationScope.FULL_NAME,
                AppleAuthentication.AppleAuthenticationScope.EMAIL,
              ],
            });

            if (!credential.identityToken) {
              throw new Error('No identity token received from Apple');
            }

            const result = await authClient.signIn.social({
              provider: 'apple',
              idToken: {
                token: credential.identityToken,
              },
            });

            if (result.error) {
              throw new Error(result.error.message || 'Apple sign in failed');
            }
            return { success: true };
          } catch (appleError: any) {
            if (appleError.code === 'ERR_REQUEST_CANCELED') {
              throw new Error('Sign in cancelled');
            }
            throw appleError;
          }
        }
      }

      // Android or iOS native unavailable: Use browser OAuth
      console.log('Native Apple Sign-In unavailable, using browser fallback');
      const result = await authClient.signIn.social({
        provider: 'apple',
        callbackURL,
        errorCallbackURL,
      });

      if (result.error) {
        throw new Error(result.error.message || 'Apple sign in failed');
      }
      return { success: true };
    } catch (err: any) {
      const message = err instanceof Error ? err.message : 'Apple sign in failed';
      setError(message);
      return { success: false, error: message };
    } finally {
      setIsLoading(false);
    }
  }, []);
<% } %>
<% if (features.authentication.providers.github) { %>
  /**
   * GitHub Sign In - Browser OAuth only (no native SDK exists)
   */
  const signInWithGitHub = useCallback(async (
    callbackURL: string = "/(tabs)",
    errorCallbackURL: string = "/(auth)/login"
  ) => {
    setIsLoading(true);
    setError(null);

    try {
      const result = await authClient.signIn.social({
        provider: 'github',
        callbackURL,
        errorCallbackURL,
      });

      if (result.error) {
        throw new Error(result.error.message || 'GitHub sign in failed');
      }
      return { success: true };
    } catch (err: any) {
      const message = err instanceof Error ? err.message : 'GitHub sign in failed';
      setError(message);
      return { success: false, error: message };
    } finally {
      setIsLoading(false);
    }
  }, []);
<% } %>

  // Update profile (custom endpoint)
  const updateProfile = useCallback(async (data: { name?: string }) => {
    setIsLoading(true);
    try {
      const response = await fetch(`${API_URL}/api/auth/profile`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Cookie': getCookies() || '',
        },
        credentials: 'omit',
        body: JSON.stringify(data),
      });
      if (!response.ok) {
        throw new Error('Update failed');
      }
      // Refetch session to get updated user data
      await refetch();
      return { success: true };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Update failed';
      return { success: false, error: message };
    } finally {
      setIsLoading(false);
    }
  }, [refetch]);

  // Change password
  const changePassword = useCallback(async (currentPassword: string, newPassword: string) => {
    setIsLoading(true);
    try {
      const result = await authClient.changePassword({
        currentPassword,
        newPassword,
      });
      if (result.error) {
        throw new Error(result.error.message || 'Password change failed');
      }
      return { success: true };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Password change failed';
      return { success: false, error: message };
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Delete account (custom endpoint)
  const deleteAccount = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await fetch(`${API_URL}/api/auth/account`, {
        method: 'DELETE',
        headers: {
          'Cookie': getCookies() || '',
        },
        credentials: 'omit',
      });
      if (!response.ok) {
        throw new Error('Delete account failed');
      }
      return { success: true };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Delete account failed';
      return { success: false, error: message };
    } finally {
      setIsLoading(false);
    }
  }, []);
<% if (features.authentication.twoFactor) { %>

  // Verify TOTP code during login (2FA challenge)
  const verifyTotpLogin = useCallback(async (code: string, trustDevice?: boolean) => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await authClient.twoFactor.verifyTotp({
        code,
        trustDevice,
      });
      if (result.error) {
        throw new Error(result.error.message || 'Invalid verification code');
      }
      // Clear 2FA state on successful verification
      await clearTwoFactorState();
      return { success: true };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Verification failed';
      setError(message);
      return { success: false, error: message };
    } finally {
      setIsLoading(false);
    }
  }, [clearTwoFactorState]);

  // Verify backup code during login
  const verifyBackupCode = useCallback(async (code: string) => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await authClient.twoFactor.verifyBackupCode({
        code,
      });
      if (result.error) {
        throw new Error(result.error.message || 'Invalid backup code');
      }
      // Clear 2FA state on successful verification
      await clearTwoFactorState();
      return { success: true };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Verification failed';
      setError(message);
      return { success: false, error: message };
    } finally {
      setIsLoading(false);
    }
  }, [clearTwoFactorState]);

  // Enable 2FA - initiates the setup flow and returns TOTP URI + backup codes
  const enableTwoFactor = useCallback(async (password: string) => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await authClient.twoFactor.enable({ password });
      if (result.error) {
        throw new Error(result.error.message || 'Failed to enable 2FA');
      }
      return {
        success: true,
        totpURI: result.data?.totpURI,
        backupCodes: result.data?.backupCodes,
      };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to enable 2FA';
      setError(message);
      return { success: false, error: message };
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Verify TOTP setup (confirms user has set up their authenticator correctly)
  const verifyTotpSetup = useCallback(async (code: string) => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await authClient.twoFactor.verifyTotp({ code });
      if (result.error) {
        throw new Error(result.error.message || 'Verification failed');
      }
      // Refresh session to get updated twoFactorEnabled status
      await refetch();
      return { success: true };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Verification failed';
      setError(message);
      return { success: false, error: message };
    } finally {
      setIsLoading(false);
    }
  }, [refetch]);

  // Disable 2FA
  const disableTwoFactor = useCallback(async (password: string) => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await authClient.twoFactor.disable({ password });
      if (result.error) {
        throw new Error(result.error.message || 'Failed to disable 2FA');
      }
      await refetch();
      return { success: true };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to disable 2FA';
      setError(message);
      return { success: false, error: message };
    } finally {
      setIsLoading(false);
    }
  }, [refetch]);

  // Generate new backup codes (invalidates old ones)
  const generateBackupCodes = useCallback(async (password: string) => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await authClient.twoFactor.generateBackupCodes({ password });
      if (result.error) {
        throw new Error(result.error.message || 'Failed to generate backup codes');
      }
      return {
        success: true,
        backupCodes: result.data?.backupCodes,
      };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to generate backup codes';
      setError(message);
      return { success: false, error: message };
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Check if user has a password set (for OAuth users who need to set one for 2FA)
  const checkHasPassword = useCallback(async (): Promise<boolean> => {
    try {
      const response = await fetch(`${API_URL}/api/auth/has-password`, {
        headers: {
          'Cookie': getCookies() || '',
        },
        credentials: 'omit',
      });
      const data = await response.json();
      return data.hasPassword ?? false;
    } catch {
      return false;
    }
  }, []);

  // Set initial password (for OAuth users enabling 2FA)
  const setInitialPassword = useCallback(async (password: string) => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch(`${API_URL}/api/auth/set-password`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Cookie': getCookies() || '',
        },
        credentials: 'omit',
        body: JSON.stringify({ newPassword: password }),
      });
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.message || 'Failed to set password');
      }
      return { success: true };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to set password';
      setError(message);
      return { success: false, error: message };
    } finally {
      setIsLoading(false);
    }
  }, []);
<% } %>

  const clearError = useCallback(() => setError(null), []);

  return {
    // State (from BetterAuth's useSession)
    user,
    session: session?.session ?? null,
    isAuthenticated,
    isPending,

    // Local state for UI feedback
    isLoading,
    error,

    // Actions
    signIn,
    signUp,
    signOut,
<% if (features.authentication.providers.google) { %>
    signInWithGoogle,
<% } %>
<% if (features.authentication.providers.apple) { %>
    signInWithApple,
<% } %>
<% if (features.authentication.providers.github) { %>
    signInWithGitHub,
<% } %>
    updateProfile,
    changePassword,
    deleteAccount,
    clearError,
    refetch,
<% if (features.authentication.twoFactor) { %>
    // 2FA login verification
    verifyTotpLogin,
    verifyBackupCode,
    // 2FA expiration state
    twoFactorExpiresAt,
    setTwoFactorExpiration,
    clearTwoFactorState,
    // 2FA setup/management
    enableTwoFactor,
    verifyTotpSetup,
    disableTwoFactor,
    generateBackupCodes,
    checkHasPassword,
    setInitialPassword,
<% } %>
  };
};
