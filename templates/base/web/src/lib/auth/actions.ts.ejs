'use server';

import { redirect } from 'next/navigation';
import {
  setSessionCookie,
  getSessionToken,
  clearSessionCookie,
  getDeviceSessionToken,
<% if (features.authentication.twoFactor) { %>
  setTwoFactorCookie,
  getTwoFactorToken,
  clearTwoFactorCookie,
<% } %>
} from './cookies';
import { AUTH_CONFIG, BETTER_AUTH_COOKIE_NAME<% if (features.authentication.twoFactor) { %>, BETTER_AUTH_TWO_FACTOR_COOKIE_NAME, COOKIE_NAMES<% } %> } from './config';

// Types
export interface User {
  id: string;
  email: string;
  name: string | null;
  emailVerified: boolean;
  image: string | null;
  createdAt: string;
  updatedAt: string;
<% if (features.authentication.twoFactor) { %>
  twoFactorEnabled: boolean;
<% } %>
}

export interface Session {
  id: string;
  userId: string;
  token: string;
  expiresAt: string;
  createdAt: string;
  updatedAt: string;
  ipAddress?: string;
  userAgent?: string;
}

export interface AuthSession {
  user: User;
  session: Session;
}

interface SignInResult {
  success: boolean;
  error?: string;
  session?: AuthSession;
<% if (features.authentication.emailVerification) { %>
  needsEmailVerification?: boolean;
<% } %>
<% if (features.authentication.twoFactor) { %>
  requiresTwoFactor?: boolean;
<% } %>
}

interface SignUpResult {
  success: boolean;
  error?: string;
<% if (features.authentication.emailVerification) { %>
  needsEmailVerification?: boolean;
<% } %>
}

export interface FormActionState {
  error: string | null;
  success?: boolean;
  email?: string;
}

<% if (features.authentication.twoFactor) { %>
interface EnableTwoFactorResult {
  success: boolean;
  error?: string;
  totpURI?: string;
  backupCodes?: string[];
}

interface VerifyTotpResult {
  success: boolean;
  error?: string;
  session?: AuthSession;
}
<% } %>

/**
 * Build headers for Fastify requests
 * Includes session token in Better Auth cookie format and Origin for CSRF protection.
 * Exported for reuse by other modules (e.g., sessions.ts).
 */
export async function buildAuthHeaders(): Promise<HeadersInit> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    // Origin header required for Better Auth CSRF protection
    // Server Actions run in Node.js and don't automatically include Origin
    'Origin': AUTH_CONFIG.appUrl,
  };

  // Build cookie header with all auth-related cookies
  const cookieParts: string[] = [];

  const sessionToken = await getSessionToken();
  if (sessionToken) {
    cookieParts.push(`${BETTER_AUTH_COOKIE_NAME}=${sessionToken}`);
  }

<% if (features.authentication.twoFactor) { %>
  // Include two-factor cookie if present (needed for 2FA verification)
  const twoFactorToken = await getTwoFactorToken();
  if (twoFactorToken) {
    cookieParts.push(`${BETTER_AUTH_TWO_FACTOR_COOKIE_NAME}=${twoFactorToken}`);
  }
<% } %>

  if (cookieParts.length > 0) {
    headers['Cookie'] = cookieParts.join('; ');
  }

  const deviceToken = await getDeviceSessionToken();
  if (deviceToken) {
    headers['X-Device-Session-Token'] = deviceToken;
  }

  return headers;
}

/**
 * Sign in with email and password
 */
export async function signIn(email: string, password: string): Promise<SignInResult> {
  try {
    const response = await fetch(`${AUTH_CONFIG.backendUrl}/api/auth/sign-in/email`, {
      method: 'POST',
      headers: await buildAuthHeaders(),
      body: JSON.stringify({ email, password }),
      cache: 'no-store',
    });

    const data = await response.json().catch(() => ({}));

<% if (features.authentication.twoFactor) { %>
    // Check if 2FA is required (Better Auth returns twoFactorRedirect: true)
    if (data.twoFactorRedirect) {
      // Extract and store temporary 2FA session token
      const sessionToken = extractSessionToken(response);
      if (sessionToken) {
        await setSessionCookie(sessionToken);
      }

      // Extract and store the two-factor cookie with expiration (required for TOTP verification)
      const { token: twoFactorToken, expiresAt } = extractTwoFactorTokenAndExpiration(response);
      if (twoFactorToken && expiresAt) {
        await setTwoFactorCookie(twoFactorToken, expiresAt);
      }

      return { success: true, requiresTwoFactor: true };
    }
<% } %>

    if (!response.ok) {
      return {
        success: false,
        error: data.message || 'Invalid email or password',
      };
    }

    // Extract session token from Set-Cookie header
    const sessionToken = extractSessionToken(response);

    if (!sessionToken) {
      return { success: false, error: 'No session token received' };
    }

    // Set session cookie
    await setSessionCookie(sessionToken);

    // Get session data
    const session = await getSession();

<% if (features.authentication.emailVerification) { %>
    // Check if email verification is needed
    if (session?.user?.emailVerified === false) {
      return {
        success: true,
        session: session,
        needsEmailVerification: true,
      };
    }
<% } %>

    return { success: true, session: session || undefined };
  } catch (error) {
    console.error('Sign in error:', error);
    return { success: false, error: 'An error occurred during sign in' };
  }
}

/**
 * Sign up with email and password
 */
export async function signUp(
  email: string,
  password: string,
  name?: string
): Promise<SignUpResult> {
  try {
    const response = await fetch(`${AUTH_CONFIG.backendUrl}/api/auth/sign-up/email`, {
      method: 'POST',
      headers: await buildAuthHeaders(),
      body: JSON.stringify({ email, password, name }),
      cache: 'no-store',
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      return {
        success: false,
        error: error.message || 'Failed to create account',
      };
    }

<% if (features.authentication.emailVerification) { %>
    const data = await response.json();

    // Extract and set session token (user IS logged in even if email not verified)
    const sessionToken = extractSessionToken(response);
    if (sessionToken) {
      await setSessionCookie(sessionToken);
    }

    // Check if email verification is needed by checking user's emailVerified status
    if (data.user?.emailVerified === false) {
      return { success: true, needsEmailVerification: true };
    }

    return { success: true };
<% } else { %>
    // Extract and set session token
    const sessionToken = extractSessionToken(response);

    if (sessionToken) {
      await setSessionCookie(sessionToken);
    }

    return { success: true };
<% } %>
  } catch (error) {
    console.error('Sign up error:', error);
    return { success: false, error: 'An error occurred during sign up' };
  }
}

/**
 * Sign out current session
 */
export async function signOut(): Promise<{ success: boolean }> {
  try {
    await fetch(`${AUTH_CONFIG.backendUrl}/api/auth/sign-out`, {
      method: 'POST',
      headers: await buildAuthHeaders(),
      body: JSON.stringify({}),
      cache: 'no-store',
    });
  } catch (error) {
    console.error('Sign out error:', error);
  }

  // Always clear local cookie
  await clearSessionCookie();

  return { success: true };
}

/**
 * Get current session (validates with backend)
 *
 * Note: For client-side caching, use the AuthProvider which
 * maintains a cache to avoid hitting the backend on every render.
 */
export async function getSession(): Promise<AuthSession | null> {
  const sessionToken = await getSessionToken();

  if (!sessionToken) {
    return null;
  }

  try {
    const response = await fetch(`${AUTH_CONFIG.backendUrl}/api/auth/get-session`, {
      method: 'GET',
      headers: await buildAuthHeaders(),
      cache: 'no-store',
    });

    if (!response.ok) {
      // Don't try to clear cookie here - it doesn't work in Server Components
      // Server Components can't send Set-Cookie headers when using redirect()
      // The protected layout redirects to /auth/session-expired which is a
      // Route Handler that properly clears the cookie
      return null;
    }

    const data = await response.json();
    return data as AuthSession;
  } catch (error) {
    console.error('Get session error:', error);
    return null;
  }
}

/**
 * Request password reset email
 */
export async function requestPasswordReset(
  email: string
): Promise<{ success: boolean; error?: string }> {
  try {
    const response = await fetch(`${AUTH_CONFIG.backendUrl}/api/auth/forget-password`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        email,
        redirectTo: `${AUTH_CONFIG.appUrl}/reset-password`,
      }),
      cache: 'no-store',
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      return { success: false, error: error.message || 'Failed to send reset email' };
    }

    return { success: true };
  } catch (error) {
    console.error('Password reset request error:', error);
    return { success: false, error: 'An error occurred' };
  }
}

/**
 * Reset password with token
 */
export async function resetPassword(
  token: string,
  newPassword: string
): Promise<{ success: boolean; error?: string }> {
  try {
    const response = await fetch(`${AUTH_CONFIG.backendUrl}/api/auth/reset-password`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ token, newPassword }),
      cache: 'no-store',
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      return { success: false, error: error.message || 'Failed to reset password' };
    }

    return { success: true };
  } catch (error) {
    console.error('Password reset error:', error);
    return { success: false, error: 'An error occurred' };
  }
}

// ============================================================================
// Form Actions (useActionState-compatible)
// ============================================================================

/**
 * Login form action for useActionState
 */
export async function loginAction(
  _prevState: FormActionState,
  formData: FormData
): Promise<FormActionState> {
  const email = formData.get('email') as string;
  const password = formData.get('password') as string;
  const redirectTo = (formData.get('redirectTo') as string) || '/dashboard';

  const result = await signIn(email, password);

<% if (features.authentication.twoFactor) { %>
  if (result.requiresTwoFactor) {
    redirect('/login/two-factor');
  }
<% } %>

<% if (features.authentication.emailVerification) { %>
  if (result.needsEmailVerification) {
    redirect(`/verify-email?email=${encodeURIComponent(email)}`);
  }
<% } %>

  if (!result.success) {
    return { error: result.error || 'Failed to sign in' };
  }

  redirect(redirectTo);
}

/**
 * Register form action for useActionState
 */
export async function registerAction(
  _prevState: FormActionState,
  formData: FormData
): Promise<FormActionState> {
  const name = formData.get('name') as string;
  const email = formData.get('email') as string;
  const password = formData.get('password') as string;
  const confirmPassword = formData.get('confirmPassword') as string;

  if (password !== confirmPassword) {
    return { error: 'Passwords do not match' };
  }

  if (password.length < 8) {
    return { error: 'Password must be at least 8 characters' };
  }

  const result = await signUp(email, password, name || undefined);

  if (!result.success) {
    return { error: result.error || 'Failed to create account' };
  }

<% if (features.authentication.emailVerification) { %>
  if (result.needsEmailVerification) {
    redirect(`/verify-email?email=${encodeURIComponent(email)}`);
  }
<% } %>

  redirect('/dashboard');
}

<% if (features.authentication.passwordReset) { %>
/**
 * Forgot password form action for useActionState
 */
export async function forgotPasswordAction(
  _prevState: FormActionState,
  formData: FormData
): Promise<FormActionState> {
  const email = formData.get('email') as string;

  const result = await requestPasswordReset(email);

  if (!result.success) {
    return { error: result.error || 'Failed to send reset email' };
  }

  return { error: null, success: true, email };
}

/**
 * Reset password form action for useActionState
 */
export async function resetPasswordAction(
  _prevState: FormActionState,
  formData: FormData
): Promise<FormActionState> {
  const token = formData.get('token') as string;
  const password = formData.get('password') as string;
  const confirmPassword = formData.get('confirmPassword') as string;

  if (password !== confirmPassword) {
    return { error: 'Passwords do not match' };
  }

  if (password.length < 8) {
    return { error: 'Password must be at least 8 characters' };
  }

  const result = await resetPassword(token, password);

  if (!result.success) {
    return { error: result.error || 'Failed to reset password' };
  }

  redirect('/login?message=Password+reset+successfully');
}
<% } %>

/**
 * Sign out action for form submission
 */
export async function signOutAction(_formData: FormData): Promise<void> {
  await signOut();
  redirect('/login');
}

<% if (features.authentication.emailVerification) { %>
/**
 * Send verification OTP to email
 */
export async function sendVerificationOtp(email: string): Promise<{ success: boolean; error?: string }> {
  try {
    const response = await fetch(`${AUTH_CONFIG.backendUrl}/api/auth/email-otp/send-verification-otp`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, type: 'email-verification' }),
      cache: 'no-store',
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      return { success: false, error: error.message || 'Failed to send verification code' };
    }

    return { success: true };
  } catch (error) {
    console.error('Send OTP error:', error);
    return { success: false, error: 'An error occurred' };
  }
}

/**
 * Verify email with OTP code
 */
export async function verifyEmailOtp(email: string, otp: string): Promise<{
  success: boolean;
  error?: string;
  session?: AuthSession;
}> {
  try {
    const response = await fetch(`${AUTH_CONFIG.backendUrl}/api/auth/email-otp/verify-email`, {
      method: 'POST',
      headers: await buildAuthHeaders(),  // Include existing session cookie
      body: JSON.stringify({ email, otp }),
      cache: 'no-store',
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      return { success: false, error: error.message || 'Invalid verification code' };
    }

    // Get the updated session (emailVerified is now true)
    const session = await getSession();
    return { success: true, session: session || undefined };
  } catch (error) {
    console.error('Verify OTP error:', error);
    return { success: false, error: 'An error occurred' };
  }
}
<% } %>

<% if (features.authentication.twoFactor) { %>
/**
 * Enable two-factor authentication
 * Returns TOTP URI for QR code and backup codes
 */
export async function enableTwoFactor(password: string): Promise<EnableTwoFactorResult> {
  try {
    const response = await fetch(`${AUTH_CONFIG.backendUrl}/api/auth/two-factor/enable`, {
      method: 'POST',
      headers: await buildAuthHeaders(),
      body: JSON.stringify({ password }),
      cache: 'no-store',
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      return { success: false, error: error.message || 'Failed to enable 2FA' };
    }

    const data = await response.json();
    return {
      success: true,
      totpURI: data.totpURI,
      backupCodes: data.backupCodes,
    };
  } catch (error) {
    console.error('Enable 2FA error:', error);
    return { success: false, error: 'An error occurred' };
  }
}

/**
 * Verify TOTP code during 2FA setup (activates 2FA)
 */
export async function verifyTotpSetup(code: string): Promise<VerifyTotpResult> {
  try {
    const response = await fetch(`${AUTH_CONFIG.backendUrl}/api/auth/two-factor/verify-totp`, {
      method: 'POST',
      headers: await buildAuthHeaders(),
      body: JSON.stringify({ code }),
      cache: 'no-store',
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      return { success: false, error: error.message || 'Invalid verification code' };
    }

    // Extract and set session token after successful 2FA setup
    const sessionToken = extractSessionToken(response);
    if (sessionToken) {
      await setSessionCookie(sessionToken);
    }

    const session = await getSession();
    return { success: true, session: session || undefined };
  } catch (error) {
    console.error('Verify TOTP setup error:', error);
    return { success: false, error: 'An error occurred' };
  }
}

/**
 * Verify TOTP code during login (2FA challenge)
 */
export async function verifyTotpLogin(code: string, trustDevice?: boolean): Promise<VerifyTotpResult> {
  try {
    const response = await fetch(`${AUTH_CONFIG.backendUrl}/api/auth/two-factor/verify-totp`, {
      method: 'POST',
      headers: await buildAuthHeaders(),
      body: JSON.stringify({ code, trustDevice }),
      cache: 'no-store',
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      return { success: false, error: error.message || 'Invalid verification code' };
    }

    // Extract and set session token after successful 2FA
    const sessionToken = extractSessionToken(response);
    if (sessionToken) {
      await setSessionCookie(sessionToken);
    }

    // Clear 2FA cookies after successful verification
    await clearTwoFactorCookie();

    const session = await getSession();
    return { success: true, session: session || undefined };
  } catch (error) {
    console.error('Verify TOTP login error:', error);
    return { success: false, error: 'An error occurred' };
  }
}

/**
 * Disable two-factor authentication
 */
export async function disableTwoFactor(password: string): Promise<{ success: boolean; error?: string }> {
  try {
    const response = await fetch(`${AUTH_CONFIG.backendUrl}/api/auth/two-factor/disable`, {
      method: 'POST',
      headers: await buildAuthHeaders(),
      body: JSON.stringify({ password }),
      cache: 'no-store',
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      return { success: false, error: error.message || 'Failed to disable 2FA' };
    }

    return { success: true };
  } catch (error) {
    console.error('Disable 2FA error:', error);
    return { success: false, error: 'An error occurred' };
  }
}

/**
 * Generate new backup codes
 */
export async function generateBackupCodes(password: string): Promise<{ success: boolean; error?: string; backupCodes?: string[] }> {
  try {
    const response = await fetch(`${AUTH_CONFIG.backendUrl}/api/auth/two-factor/generate-backup-codes`, {
      method: 'POST',
      headers: await buildAuthHeaders(),
      body: JSON.stringify({ password }),
      cache: 'no-store',
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      return { success: false, error: error.message || 'Failed to generate backup codes' };
    }

    const data = await response.json();
    return { success: true, backupCodes: data.backupCodes };
  } catch (error) {
    console.error('Generate backup codes error:', error);
    return { success: false, error: 'An error occurred' };
  }
}

/**
 * Verify backup code during login
 */
export async function verifyBackupCode(code: string): Promise<VerifyTotpResult> {
  try {
    const response = await fetch(`${AUTH_CONFIG.backendUrl}/api/auth/two-factor/verify-backup-code`, {
      method: 'POST',
      headers: await buildAuthHeaders(),
      body: JSON.stringify({ code }),
      cache: 'no-store',
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      return { success: false, error: error.message || 'Invalid backup code' };
    }

    const sessionToken = extractSessionToken(response);
    if (sessionToken) {
      await setSessionCookie(sessionToken);
    }

    // Clear 2FA cookies after successful verification
    await clearTwoFactorCookie();

    const session = await getSession();
    return { success: true, session: session || undefined };
  } catch (error) {
    console.error('Verify backup code error:', error);
    return { success: false, error: 'An error occurred' };
  }
}

/**
 * Check if user has a password (credential account)
 * Used to determine if OAuth user needs to set password before enabling 2FA
 */
export async function checkHasPassword(): Promise<{ hasPassword: boolean }> {
  try {
    const response = await fetch(`${AUTH_CONFIG.backendUrl}/api/auth/has-password`, {
      method: 'GET',
      headers: await buildAuthHeaders(),
      cache: 'no-store',
    });

    if (!response.ok) {
      return { hasPassword: false };
    }

    return response.json();
  } catch (error) {
    console.error('Check has password error:', error);
    return { hasPassword: false };
  }
}

/**
 * Set initial password for OAuth users
 * Allows OAuth users to add a password to their account for 2FA
 */
export async function setInitialPassword(
  newPassword: string
): Promise<{ success: boolean; error?: string }> {
  try {
    const response = await fetch(`${AUTH_CONFIG.backendUrl}/api/auth/set-password`, {
      method: 'POST',
      headers: await buildAuthHeaders(),
      body: JSON.stringify({ newPassword }),
      cache: 'no-store',
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      return { success: false, error: error.message || 'Failed to set password' };
    }

    return { success: true };
  } catch (error) {
    console.error('Set initial password error:', error);
    return { success: false, error: 'An error occurred' };
  }
}
<% } %>

/**
 * Extract session token from Set-Cookie header
 *
 * IMPORTANT: In Node.js 20+, use headers.getSetCookie() to get an array of cookies.
 * The headers.get("set-cookie") method joins cookies with commas, which breaks
 * parsing because cookie attributes like Expires contain commas (e.g., "Thu, 01 Jan 2025").
 */
function extractSessionToken(response: Response): string | null {
  // Use getSetCookie() for proper cookie array handling (Node.js 20+)
  // This returns an array of individual Set-Cookie header values
  const setCookies = response.headers.getSetCookie?.() ?? [];

  // Fallback for older Node.js versions or environments without getSetCookie
  if (setCookies.length === 0) {
    const setCookieHeader = response.headers.get('set-cookie');
    if (!setCookieHeader) return null;

    // Manual parsing fallback - split on ", " followed by a cookie name pattern
    // This handles most cases but getSetCookie() is preferred
    const cookiePattern = new RegExp(`${BETTER_AUTH_COOKIE_NAME}=([^;]+)`);
    const match = setCookieHeader.match(cookiePattern);
    return match ? match[1] : null;
  }

  for (const cookie of setCookies) {
    const match = cookie.match(new RegExp(`${BETTER_AUTH_COOKIE_NAME}=([^;]+)`));
    if (match) {
      return match[1];
    }
  }

  return null;
}
<% if (features.authentication.twoFactor) { %>

/**
 * Extract two-factor token and expiration from Set-Cookie header
 * Used during 2FA verification flow
 *
 * Extracts the absolute Expires attribute to avoid time delta issues between
 * backend and frontend.
 */
function extractTwoFactorTokenAndExpiration(response: Response): {
  token: string | null;
  expiresAt: number | null; // Absolute Unix timestamp (seconds)
} {
  const setCookies = response.headers.getSetCookie?.() ?? [];
  let token: string | null = null;
  let expiresAt: number | null = null;

  /**
   * Parse expiration from a cookie string.
   * Handles both Expires (absolute) and Max-Age (relative) attributes.
   *
   * IMPORTANT: We subtract a safety buffer when using Max-Age to account for
   * the time delta between when the backend created the cookie (t_0) and when
   * we process it (t_1). This ensures our cookie expires BEFORE the backend's,
   * preventing edge cases where we think we have a valid token but the backend
   * has already expired it.
   */
  const SAFETY_BUFFER_SECONDS = 5;

  const parseExpiration = (cookie: string): number | null => {
    // Try Expires first (absolute timestamp) - no buffer needed since it's absolute
    const expiresMatch = cookie.match(/Expires=([^;]+)/i);
    if (expiresMatch) {
      const parsedDate = new Date(expiresMatch[1]);
      if (!isNaN(parsedDate.getTime())) {
        return Math.floor(parsedDate.getTime() / 1000);
      }
    }

    // Fall back to Max-Age (relative seconds from now)
    // Subtract safety buffer to ensure we expire before the backend
    const maxAgeMatch = cookie.match(/Max-Age=(\d+)/i);
    if (maxAgeMatch) {
      const maxAgeSeconds = parseInt(maxAgeMatch[1], 10);
      return Math.floor(Date.now() / 1000) + maxAgeSeconds - SAFETY_BUFFER_SECONDS;
    }

    return null;
  };

  if (setCookies.length === 0) {
    const setCookieHeader = response.headers.get('set-cookie');
    if (!setCookieHeader) return { token: null, expiresAt: null };

    const tokenMatch = setCookieHeader.match(
      new RegExp(`${BETTER_AUTH_TWO_FACTOR_COOKIE_NAME}=([^;]+)`)
    );
    token = tokenMatch ? tokenMatch[1] : null;

    if (token) {
      expiresAt = parseExpiration(setCookieHeader);
    }
    return { token, expiresAt };
  }

  for (const cookie of setCookies) {
    const tokenMatch = cookie.match(
      new RegExp(`${BETTER_AUTH_TWO_FACTOR_COOKIE_NAME}=([^;]+)`)
    );
    if (tokenMatch) {
      token = tokenMatch[1];
      expiresAt = parseExpiration(cookie);
      break;
    }
  }

  return { token, expiresAt };
}
<% } %>
